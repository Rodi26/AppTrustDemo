on:
  workflow_dispatch:
  workflow_call:

permissions:
  actions: read           # for detecting the Github Actions environment
  id-token: write         # for creating OIDC tokens for signing
  packages: write         # for uploading attestations
  contents: read          # read the contents permission
  security-events: write  # for uploading code scanning

jobs:
  promote-application:
    name: Promote Latest Application Version
    runs-on: ubuntu-latest
    env:
      JF_URL: ${{ vars.JF_URL }}
      # JF_USER: ${{ vars.JF_USER }}
      # JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
      # AppTrust application identifier (a.k.a. application key / slug). Must match the key used in AppTrust APIs.
      # Backward-compatible fallback: if APPLICATION_KEY is not set, use APPLICATION_NAME.
      APP_ID: ${{ vars.APPLICATION_KEY || vars.APPLICATION_NAME }}
      # Human-readable name (optional, used only for docs/predicate readability)
      APP_DISPLAY_NAME: ${{ vars.APPLICATION_DISPLAY_NAME || vars.APPLICATION_NAME }}
      TARGET_STAGE: ${{ vars.TARGET_STAGE }}
      JFROG_CLI_KEY_ALIAS: ${{ vars.JFROG_CLI_KEY_ALIAS }}
      JFROG_CLI_SIGNING_KEY: ${{ secrets.JFROG_CLI_SIGNING_KEY }}
      # DOCKER_REGISTRY: ${{ vars.DOCKER_QA_REGISTRY }}
      SOURCE_BUILD_NAME_BACKEND: "btcwallet"
      SOURCE_BUILD_NAME_FRONTEND: "btcwallet-ui"
      SOURCE_BUILD_NAME_SERVICE: "ai-translate"
      JF_PROJECT: ${{ vars.JF_PROJECT }}
      DOCKER_REGISTRY_PREFIX: ${{ vars.DOCKER_REGISTRY_PREFIX }}
      PROJECT_DOCKER_QA_REPO: ${{ vars.PROJECT_DOCKER_QA_REPO }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        with:
          version: 2.89.0
          oidc-provider-name: btcwallet-gh
          oidc-audience: btcwallet-gh
          custom-server-id: setup-jfrog-cli-server
        id: setup-cli
        env:
          JF_URL: ${{ vars.JF_URL }}
          # JF_USER: ${{ vars.JF_USER }}
          # JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}

      - name: Normalize JFrog CLI base URL for AppTrust
        id: normalize-cli
        run: |
          set -euo pipefail

          # Determine the server-id created by the setup action.
          # The action exports SETUP_JFROG_CLI_SERVER_IDS (can be a single id or comma-separated list).
          SERVER_ID="${SETUP_JFROG_CLI_SERVER_IDS%%,*}"
          if [ -z "${SERVER_ID:-}" ]; then
            echo "‚ö†Ô∏è  SETUP_JFROG_CLI_SERVER_IDS is empty; cannot determine JFrog CLI server-id for normalization." >&2
            exit 0
          fi
          echo "Using JFrog CLI server-id: $SERVER_ID"

          # JFrog CLI v2.82.0 does not support `jf c show <id> --json`.
          # Parse the configured URL from the human-readable output.
          SHOW_OUT=$(jf c show "$SERVER_ID" || true)
          echo "$SHOW_OUT"

          # Extract the URL from "JFrog Platform URL:" line (handles tabs and spaces)
          CFG_URL=$(echo "$SHOW_OUT" | grep -i "JFrog Platform URL" | sed -E 's/.*JFrog Platform URL:[[:space:]]*//' | sed 's/[[:space:]]*$//' | head -n 1)

          # Fallback: if not found, try other possible formats
          if [ -z "${CFG_URL:-}" ]; then
            CFG_URL=$(echo "$SHOW_OUT" | grep -iE "^[Uu][Rr][Ll]:" | sed -E 's/^[Uu][Rr][Ll]:[[:space:]]*//' | head -n 1)
          fi

          if [ -z "${CFG_URL:-}" ]; then
            echo "‚ö†Ô∏è  Could not parse JFrog CLI configured url from 'jf c show'. Skipping normalization." >&2
            exit 0
          fi

          # Trim trailing slash for consistent matching
          CFG_URL="${CFG_URL%/}"
          echo "JFrog CLI configured url: $CFG_URL"

          # If the configured URL ends with /apptrust, strip it. Otherwise keep as-is.
          if [[ "$CFG_URL" == */apptrust ]]; then
            BASE_URL="${CFG_URL%/apptrust}"
            echo "Detected url ending with /apptrust. Normalizing to: $BASE_URL"

            jf c add "$SERVER_ID" \
              --url "$BASE_URL" \
              --access-token "${{ steps.setup-cli.outputs.oidc-token }}" \
              --interactive=false \
              --overwrite=true
          else
            echo "No normalization needed."
          fi

          # Print final config
          FINAL_OUT=$(jf c show "$SERVER_ID" || true)
          echo "$FINAL_OUT"

          # Export SERVER_ID as output for use in subsequent steps
          echo "server_id=$SERVER_ID" >> "$GITHUB_OUTPUT"

      - name: Configure dedicated JFrog CLI server for AppTrust endpoints
        id: apptrust_server
        run: |
          set -euo pipefail

          # Create a dedicated server-id whose *Platform URL* includes the /apptrust prefix.
          # This is needed because some AppTrust-related CLI subcommands resolve endpoints relative to the Platform URL.
          # We explicitly set the other service URLs to keep Artifactory/Xray/etc pointing to their standard base paths.
          APPTRUST_SERVER_ID="apptrust-jfrog-cli-server"

          jf c add "$APPTRUST_SERVER_ID" \
            --url "${JF_URL%/}/apptrust" \
            --artifactory-url "${JF_URL%/}/artifactory" \
            --xray-url "${JF_URL%/}/xray" \
            --distribution-url "${JF_URL%/}/distribution" \
            --mission-control-url "${JF_URL%/}/mc" \
            --pipelines-url "${JF_URL%/}/pipelines" \
            --access-token "${{ steps.setup-cli.outputs.oidc-token }}" \
            --interactive=false \
            --overwrite=true

          echo "Configured AppTrust server-id: $APPTRUST_SERVER_ID"
          jf c show "$APPTRUST_SERVER_ID" || true

          # Export server id for later steps
          echo "server_id=$APPTRUST_SERVER_ID" >> "$GITHUB_OUTPUT"
      - name: Get latest application version
        id: get_app_ver
        run: |
          # Use the API to get the latest version.
          # We use limit=1 and order_by=created to get the most recent version.
          API_URL="$JF_URL/apptrust/api/v1/applications/$APP_ID/versions?order_by=created&limit=1"

          if [ -z "${APP_ID:-}" ]; then
            echo "‚ùå APP_ID is empty. Please set GitHub variable APPLICATION_KEY (recommended) or ensure APPLICATION_NAME contains the AppTrust application key." >&2
            exit 1
          fi

          echo "Fetching latest application version from: $API_URL"

          RESPONSE_FILE=$(mktemp)
          STATUS_CODE=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" -X GET \
            -H "Authorization: Bearer ${{ steps.setup-cli.outputs.oidc-token }}" \
            "$API_URL")

          if [ "$STATUS_CODE" != "200" ]; then
            echo "‚ùå Failed to fetch latest application version. HTTP $STATUS_CODE" >&2
            echo "URL: $API_URL" >&2
            echo "Response body:" >&2
            cat "$RESPONSE_FILE" >&2
            rm -f "$RESPONSE_FILE"
            exit 1
          fi

          RESPONSE=$(cat "$RESPONSE_FILE")
          rm -f "$RESPONSE_FILE"

          # Use jq to parse the JSON and extract the version.
          # The API returns an array 'versions', so we get the first element.
          LATEST_VER=$(echo "$RESPONSE" | jq -r '.versions[0].version')

          # Extract current stage directly from the versions list response (avoids GET /versions/{version} which can return 405)
          CURRENT_STAGE=$(echo "$RESPONSE" | jq -r '.versions[0].current_stage // .versions[0].stage // .versions[0].stages[0] // "DEV"' 2>/dev/null || echo "DEV")

          if [ "$LATEST_VER" == "null" ] || [ -z "$LATEST_VER" ]; then
            echo "Error: Could not retrieve a valid application version."
            exit 1
          fi

          # If still empty or null, default to DEV
          if [ "$CURRENT_STAGE" == "null" ] || [ -z "$CURRENT_STAGE" ]; then
            CURRENT_STAGE="DEV"
          fi

          echo "Found latest application version: $LATEST_VER"
          echo "Current stage: $CURRENT_STAGE"

          echo "app_ver=$LATEST_VER" >> $GITHUB_OUTPUT
          echo "current_stage=$CURRENT_STAGE" >> $GITHUB_OUTPUT

      - name: Preflight verify AppTrust application object is reachable
        run: |
          set -euo pipefail
          APP_DETAILS_URL="$JF_URL/apptrust/api/v1/applications/$APP_ID"
          echo "Checking AppTrust application details: $APP_DETAILS_URL"

          RESPONSE_FILE=$(mktemp)
          STATUS_CODE=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" -X GET \
            -H "Authorization: Bearer ${{ steps.setup-cli.outputs.oidc-token }}" \
            "$APP_DETAILS_URL")

          if [ "$STATUS_CODE" != "200" ]; then
            echo "‚ùå AppTrust application object is not reachable (HTTP $STATUS_CODE). Evidence cannot be attached to application/version until this is fixed." >&2
            echo "URL: $APP_DETAILS_URL" >&2
            echo "Response body:" >&2
            cat "$RESPONSE_FILE" >&2
            rm -f "$RESPONSE_FILE"
            exit 1
          fi

          echo "‚úÖ AppTrust application object reachable."
          rm -f "$RESPONSE_FILE"

      - name: Create gate certification evidence for DEV stage (before promotion)
        if: steps.get_app_ver.outputs.current_stage == 'DEV'
        env:
          JFROG_CLI_BUILD_PROJECT: ${{ env.JF_PROJECT }}
        run: |
          set -euo pipefail
          echo "üìã Creating gate certification evidence for DEV stage before promotion..."
          APP_VER=${{ steps.get_app_ver.outputs.app_ver }}
          STAGE="btcwallet-dev"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "Creating DEV exit gate evidence for:"
          echo "  Application: ${{ env.APP_ID }}"
          echo "  Version: $APP_VER"
          echo "  Stage: $STAGE"
          echo "  Timestamp: $TIMESTAMP"
          echo "  Project: ${{ env.JF_PROJECT }}"
          
          # Create predicate JSON
          cat > gate-certify-predicate-dev.json <<EOF
          {
            "application_key": "${{ env.APP_ID }}",
            "application_name": "${{ env.APP_DISPLAY_NAME }}",
            "stage": "$STAGE",
            "gate": "exit",
            "status": "certified",
            "timestamp": "$TIMESTAMP"
          }
          EOF
          
          echo "Predicate JSON content:"
          cat gate-certify-predicate-dev.json
          
          # Create markdown documentation
          cat > gate-certify-dev.md <<EOF
          # Gate Certification Evidence - DEV Stage
          
          - **Stage**: $STAGE
          - **Gate Type**: exit
          - **Status**: certified
          - **Timestamp**: $TIMESTAMP
          - **Application**: ${{ env.APP_ID }}
          - **Application Name**: ${{ env.APP_DISPLAY_NAME }}
          - **Version**: $APP_VER
          EOF

          jf evd create \
              --application-key "${{ env.APP_ID }}" \
              --application-version "$APP_VER" \
              --predicate gate-certify-predicate-dev.json \
              --predicate-type https://jfrog.com/evidence/apptrust/gate-certify/v1 \
              --markdown gate-certify-dev.md \
              --provider-id apptrust

          echo "‚úÖ DEV gate certification evidence created successfully"

      - name: Promote application to ${{ env.TARGET_STAGE }}
        id: promote_step
        run: |
          set -euo pipefail
          APP_VER=${{ steps.get_app_ver.outputs.app_ver }}
          CURRENT_STAGE="${{ steps.get_app_ver.outputs.current_stage }}"
          
          # Normalize stage names (trim whitespace, convert to uppercase for comparison)
          CURRENT_STAGE_NORM=$(echo "$CURRENT_STAGE" | tr '[:lower:]' '[:upper:]' | xargs)
          TARGET_STAGE_NORM=$(echo "$TARGET_STAGE" | tr '[:lower:]' '[:upper:]' | xargs)
          
          echo "Debug: CURRENT_STAGE='$CURRENT_STAGE' (normalized: '$CURRENT_STAGE_NORM')"
          echo "Debug: TARGET_STAGE='$TARGET_STAGE' (normalized: '$TARGET_STAGE_NORM')"
          
          # Check if already in target stage
          if [ "$CURRENT_STAGE_NORM" == "$TARGET_STAGE_NORM" ]; then
            echo "‚ÑπÔ∏è  Application '$APP_ID' version $APP_VER is already in stage '$TARGET_STAGE'."
            echo "Skipping promotion (no action needed)."
            echo "promotion_skipped=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          REQUEST_BODY="{\"target_stage\":\"$TARGET_STAGE\"}"
          
          PROMOTION_URL="$JF_URL/apptrust/api/v1/applications/$APP_ID/versions/$APP_VER/promote"
          echo "Promoting application '$APP_ID' version $APP_VER from stage '$CURRENT_STAGE' to stage '$TARGET_STAGE'..."
          echo "Promotion URL: $PROMOTION_URL"
          
          # Capture full response for better error diagnostics
          RESPONSE_FILE=$(mktemp)
          STATUS_CODE=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${{ steps.setup-cli.outputs.oidc-token }}" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_BODY" \
            "$PROMOTION_URL")
          
          echo "Promotion request returned status code: $STATUS_CODE"
          
          # The API returns 200, 201, or 202 on success, depending on the promotion process.
          if [[ "$STATUS_CODE" -ge 200 && "$STATUS_CODE" -le 202 ]]; then
            echo "‚úÖ Successfully promoted $APP_ID version $APP_VER to $TARGET_STAGE."
            cat "$RESPONSE_FILE"
            rm "$RESPONSE_FILE"
            echo "promotion_skipped=false" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå Failed to promote application. HTTP status code: $STATUS_CODE"
            echo "Error response body:"
            cat "$RESPONSE_FILE"
            echo ""
            
            # Check for specific error patterns
            if grep -q "public_vulnerability" "$RESPONSE_FILE"; then
              echo "‚ö†Ô∏è  Error related to vulnerability data provider detected."
              echo "This may indicate a policy rule requiring vulnerability data that cannot be fetched."
              echo "Please check:"
              echo "  1. If vulnerability scan evidence is required, ensure it exists for this application version"
              echo "  2. If vulnerability policies are configured, verify they are correctly set up"
              echo "  3. Contact JFrog Platform admin if the vulnerability data provider service is misconfigured"
            fi
            
            if grep -q "gate-certify\|gate certification\|exit gate" "$RESPONSE_FILE"; then
              echo "‚ö†Ô∏è  Error related to exit gate certification detected."
              echo "This may indicate missing exit gate evidence for the source stage."
            fi
            
            rm "$RESPONSE_FILE"
            exit 1
          fi

      - name: Create gate certification evidence for ${{ env.TARGET_STAGE }} stage (after promotion)
        if: success() && steps.promote_step.outcome == 'success'
        env:
          JFROG_CLI_BUILD_PROJECT: ${{ env.JF_PROJECT }}
        run: |
          set -euo pipefail
          echo "üìã Creating gate certification evidence for ${{ env.TARGET_STAGE }} stage after successful promotion..."
          APP_VER=${{ steps.get_app_ver.outputs.app_ver }}
          TARGET_STAGE="${{ env.TARGET_STAGE }}"
          
          # Map TARGET_STAGE names to match gate configuration
          if [ "$TARGET_STAGE" == "QA" ]; then
            STAGE="btcwallet-QA"
          elif [ "$TARGET_STAGE" == "PreProd" ] || [ "$TARGET_STAGE" == "PREPROD" ]; then
            STAGE="btcwallet-PreProd"
          else
            STAGE="$TARGET_STAGE"
          fi
          
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "Creating evidence for stage: $STAGE (target stage: $TARGET_STAGE)"
          echo "Application: ${{ env.APP_ID }}"
          echo "Version: $APP_VER"
          echo "Stage: $STAGE"
          echo "Timestamp: $TIMESTAMP"
          echo "Project: ${{ env.JF_PROJECT }}"
          
          # Create predicate JSON
          cat > gate-certify-predicate.json <<EOF
          {
            "application_key": "${{ env.APP_ID }}",
            "application_name": "${{ env.APP_DISPLAY_NAME }}",
            "stage": "$STAGE",
            "gate": "exit",
            "status": "certified",
            "timestamp": "$TIMESTAMP"
          }
          EOF
          
          echo "Predicate JSON content:"
          cat gate-certify-predicate.json
          
          # Create markdown documentation
          cat > gate-certify.md <<EOF
          # Gate Certification Evidence - $STAGE Stage

          - **Stage**: $STAGE
          - **Gate Type**: exit
          - **Status**: certified
          - **Timestamp**: $TIMESTAMP
          - **Application**: ${{ env.APP_ID }}
          - **Application Name**: ${{ env.APP_DISPLAY_NAME }}
          - **Version**: $APP_VER
          EOF

          echo "Creating AppTrust gate certification evidence for $STAGE using JFrog CLI..."

          jf evd create \
              --application-key "${{ env.APP_ID }}" \
              --application-version "$APP_VER" \
              --predicate gate-certify-predicate.json \
              --predicate-type https://jfrog.com/evidence/apptrust/gate-certify/v1 \
              --markdown gate-certify.md \
              --provider-id apptrust

          echo "‚úÖ Gate certification evidence created successfully for $STAGE"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: e2e-tests/package-lock.json

      - name: Login to Docker Registry
        run: |
          echo "üîê Logging into JFrog Artifactory Docker registry..."
          echo "Registry: ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}"
          echo ${{ steps.setup-cli.outputs.oidc-token }} | docker login -u ${{ steps.setup-cli.outputs.oidc-user }} --password-stdin ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}
          echo "‚úÖ Successfully logged into Docker registry"

      - name: Get latest Docker images from Artifactory for QA environment
        id: get-images
        run: |
          set +e
          APP_VER=${{ steps.get_app_ver.outputs.app_ver }}
          URL="$JF_URL/apptrust/api/v1/applications/$APP_ID/versions/$APP_VER/content?include=sources"
          echo "Requesting application sources: $URL"
          STATUS_CODE=$(curl -s -o result.json -w "%{http_code}" -X GET -H "Authorization: Bearer ${{ steps.setup-cli.outputs.oidc-token }}" "$URL")

          if [ "$STATUS_CODE" != "200" ]; then
            echo "Request failed with code $STATUS_CODE"
            # Running again without silent to see errors
            curl -X GET -H "Authorization: Bearer ${{ steps.setup-cli.outputs.oidc-token }}" "$URL"
            exit 1
          fi

          BTCWALLET_NUM=""
          UI_NUM=""

          while read -r build_info; do
            name=$(echo "$build_info" | jq -r '.name')
            number=$(echo "$build_info" | jq -r '.number')
            echo "Found build with name: $name and number: $number"
            [ "$name" == "${{ env.SOURCE_BUILD_NAME_BACKEND }}" ] && BTCWALLET_NUM="$number"
            [ "$name" == "${{ env.SOURCE_BUILD_NAME_FRONTEND }}" ] && UI_NUM="$number"
          done < <(cat result.json | jq -c '.sources[] | {name: .build.name, number: .build.number}')

          if [ "" == "$BTCWALLET_NUM" -o "" == "$UI_NUM" ]; then
            echo "${{ env.SOURCE_BUILD_NAME_BACKEND }} or ${{ env.SOURCE_BUILD_NAME_FRONTEND }} version (or both) could not be found."
            echo "BTCWALLET_NUM=$BTCWALLET_NUM UI_NUM=$UI_NUM"
            exit 1
          fi

          # Set output variables
          echo "btcwallet_version=$BTCWALLET_NUM" >> $GITHUB_OUTPUT
          echo "ui_version=$UI_NUM" >> $GITHUB_OUTPUT
          
          echo "üìã Image Summary:"
          echo "- BTCWallet: ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}/${{ env.SOURCE_BUILD_NAME_BACKEND }}:$BTCWALLET_NUM"
          echo "- BTCWallet UI: ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}/${{ env.SOURCE_BUILD_NAME_FRONTEND }}:$UI_NUM"

      - name: Pull Docker images
        run: |
          echo "üì• Pulling Docker images..."
          
          # Pull btcwallet image
          echo "üì¶ Pulling ${{ env.SOURCE_BUILD_NAME_BACKEND }} image..."
          docker pull ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}/${{ env.SOURCE_BUILD_NAME_BACKEND }}:${{ steps.get-images.outputs.btcwallet_version }}

          # Pull btcwallet-ui image
          echo "üì¶ Pulling ${{ env.SOURCE_BUILD_NAME_FRONTEND }} image..."
          docker pull ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}/${{ env.SOURCE_BUILD_NAME_FRONTEND }}:${{ steps.get-images.outputs.ui_version }}

          echo "‚úÖ All images pulled successfully"

      - name: Start Docker services
        run: |
          echo "üöÄ Starting Docker services..."
          
          # Start btcwallet service
          echo "üîß Starting ${{ env.SOURCE_BUILD_NAME_BACKEND }} service..."
          docker run -d --name ${{ env.SOURCE_BUILD_NAME_BACKEND }}-service \
            -p 8001:8001 \
            ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}/${{ env.SOURCE_BUILD_NAME_BACKEND }}:${{ steps.get-images.outputs.btcwallet_version }}

          # Start btcwallet-ui service
          echo "üîß Starting ${{ env.SOURCE_BUILD_NAME_FRONTEND }} service..."
          docker run -d --name ${{ env.SOURCE_BUILD_NAME_FRONTEND }}-service \
            -p 8081:80 \
            --add-host host.docker.internal:host-gateway \
            ${{ env.DOCKER_REGISTRY_PREFIX }}/${{ env.PROJECT_DOCKER_QA_REPO }}/${{ env.SOURCE_BUILD_NAME_FRONTEND }}:${{ steps.get-images.outputs.ui_version }}

          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          sleep 10
          
          # Check if services are running
          if ! docker ps | grep -q ${{ env.SOURCE_BUILD_NAME_BACKEND }}-service; then
            echo "‚ùå ${{ env.SOURCE_BUILD_NAME_BACKEND }} service failed to start"
            docker logs ${{ env.SOURCE_BUILD_NAME_BACKEND }}-service
            exit 1
          fi
          
          if ! docker ps | grep -q ${{ env.SOURCE_BUILD_NAME_FRONTEND }}-service; then
            echo "‚ùå ${{ env.SOURCE_BUILD_NAME_FRONTEND }} service failed to start"
            docker logs ${{ env.SOURCE_BUILD_NAME_FRONTEND }}-service
            exit 1
          fi
          
          echo "‚úÖ All services started successfully"

      - name: Install E2E test dependencies
        run: |
          echo "üì¶ Installing E2E test dependencies..."
          cd e2e-tests
          npm ci
          echo "‚úÖ Dependencies installed"

      - name: Run E2E tests with report generation
        run: |
          echo "üß™ Running E2E tests with report generation..."
          cd e2e-tests
          
          # Run tests and generate reports
          npm run test:report
          
          echo "‚úÖ Tests completed and reports generated"

      - name: Verify test results
        run: |
          echo "üîç Verifying test results..."
          cd e2e-tests
          
          # Check if reports were generated
          if [ ! -f "test-report.md" ]; then
            echo "‚ùå Markdown report not found"
            exit 1
          fi
          
          if [ ! -f "test-report.json" ]; then
            echo "‚ùå JSON report not found"
            exit 1
          fi
          
          # Check test results from JSON
          TOTAL_TESTS=$(jq -r '.summary.totalTests' test-report.json)
          PASSING_TESTS=$(jq -r '.summary.passing' test-report.json)
          FAILING_TESTS=$(jq -r '.summary.failing' test-report.json)
          
          echo "üìä Test Results:"
          echo "- Total Tests: $TOTAL_TESTS"
          echo "- Passing: $PASSING_TESTS"
          echo "- Failing: $FAILING_TESTS"
          
          if [ "$FAILING_TESTS" -gt 0 ]; then
            echo "‚ùå Some tests failed"
            exit 1
          fi
          
          echo "‚úÖ All tests passed successfully"

      - name: Create evidence from test results
        run: |
          echo "üìã Creating evidence from test results..."
          cd e2e-tests

          EVIDENCE_PATH="${{ env.JF_PROJECT }}-application-versions/${{ env.APP_ID }}/${{ steps.get_app_ver.outputs.app_ver }}/release-bundle.json.evd"
          
          jf evd create \
              --subject-repo-path="$EVIDENCE_PATH" \
              --project ${{ env.JF_PROJECT }} \
              --predicate test-report.json \
              --predicate-type https://cypress.io/evidence/e2e/v1 \
              --markdown test-report.md \
              --provider-id cypress
                   
          echo "‚úÖ Evidence created successfully"
          
          # Write evidence path to attestation paths file for automatic evidence collection
          ATTESTATION_PATHS_FILE="/home/runner/work/_temp/created_attestation_paths.txt"
          mkdir -p "$(dirname "$ATTESTATION_PATHS_FILE")"
          echo "$EVIDENCE_PATH" >> "$ATTESTATION_PATHS_FILE"
          echo "üìù Written evidence path to attestation paths file: $EVIDENCE_PATH"